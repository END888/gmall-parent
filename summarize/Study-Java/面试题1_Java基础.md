---
title: 面试题1_Java基础
date: 2022-08-16
author: yincy
---

### 面试题1_Java基础

#### 1、面向对象和面向过程的区别？

面向对象和面向过程都是软件开发的一种思想

1、面向过程：可以理解为按照步骤去解决问题；

2、面向对象：可以理解为将一个具体的事物抽象出它的属性和行为，然后将属性和行为组装起来去解决问题。





#### 2、什么是面向对象？

面向对象就是将拥有属性和行为的事物抽象为一个类，在使用的时候，通过这个类的对象就可以获取和使用该对象的属性和方法。

**封装：**将一个事物的属性和行为封装到一个类里面，对类内部的属性或者方法等结构进行设置，让外部该访问的访问，不该访问的不能访问，具体是通过权限修饰符来实现的，常见的就是将类内部的属性私有化，并提供getter、setter方法；当然有些属性并不一定要设置getter、setter方法，比如AbstractStringBuilder中的char[]、String的char[]、ArrayList的Object[]、HashSet中的HashMap，都没有对外提供getter、setter方法，只是用来存储元素的数据结构，还有就是单例模式的应用，对类的构造器进行私有化，在内部进行实例化，仅对外暴露获取实例的方法。



**继承：**在原有类的基础上扩展出新的类，新的类也就是子类拥有父类的所有信息，在一些场景下可以实现代码的复用，并且子类也可以声明自己的属性和方法等结构。



**多态：**父类或接口定义的变量在程序编译期间，并不能确定它所指向的引用究竟是哪个具体类型，并且由该变量调用的方法在程序编译期间也不能确定调用的究竟是谁的方法，只有在程序运行期间才能确定，而多态也在框架中被大量地应用，比如我们在使用Spring进行项目开发的时候，我们可以通过@Autowired注解给一个对象的成员对象进行属性注入，它默认是按照类型进行注入的，那么此时如果声明的成员对象是接口类型的话，通过类型进行注入，就可以从Spring容器中找这个接口锁对应的实现类然后注入进来，可以方便我们对后期项目的维护，因为如果要替换某个实现类的时候，只需要让新的类去实现对应的接口即可，不用修改原来的代码，以实现代码的解耦。



---

#### 3、成员变量和局部变量的区别

（1）从语法形式上来看成员变量可以被权限修饰符修饰，而局部变量不能,当然局部变量也不能被static、volatile修饰，不过都可以被final修饰；

（2）从存储方式上来看，成员变量可以分为实例变量和类变量，实例变量是属于实例对象的，它存储在堆中的新生代或者老年代，而类变量是属于类的，它存储在元空间，局部变量是存储在Java虚拟机栈中的栈桢里面的局部变量表中的；

（3）从生命周期上看，如果是实例变量的话，会随着对象的创建而创建，随着对象的销毁而销毁；如果是类变量的话，会随着类的加载而加载；而局部变量的话，会随着方法的入栈开始，到方法的出栈而结束

---

#### 4、什么是值传递和引用传递

Java 中只有值传递，没有引用传递；

对于基本数据类型而言，传递的是变量的值；

对于引用数据类型而言，传递的是该变量所指向堆空间中对象的内存地址值

---



#### 5、Object 类中常用的方法



（1）protected Object clone()--->创建并返回此对象的一个副本。 

（2）boolean equals(Object obj)--->指示某个其他对象是否与此对象“相等”。 

（3）protected void finalize()--->当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 

（4）Class<? extendsObject> getClass()--->返回一个对象的运行时类。 

（5）int hashCode()--->返回该对象的哈希码值。 

（6）void notify()--->唤醒在此对象监视器上等待的单个线程。 

（7）void notifyAll()--->唤醒在此对象监视器上等待的所有线程。 

（8）String toString()--->返回该对象的字符串表示。 

（9）void wait()--->导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法。 

（10）void wait(long timeout)--->导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll()方法，或者超过指定的时间量。 

（11）void wait(long timeout, int nanos)--->导致当前的线程等待，直到其他线程调用此对象的notify()

---







#### 6、接口与抽象类的区别

1、从声明的形式上来看，接口是通过interface关键字声明的，而抽象类是通过abstract class进行声明的;

2、抽象类要被子类继承，接口要被类实现；

3、接口可多继承接口，但类只能单继承；

4、抽象类可以有构造器、接口不能有构造器

5、抽象类中可以定义任意权限的属性和方法，而接口默认并且只支持声明常量，方法默认是 public ，可以定义 protected、default 方法





---

#### 7、重载与重写的区别

（1）重载：在本类内部，对方法名相同，参数列表不同的方法的方法体中的代码进行修改，与方法的权限修饰符、方法返回值类型无关

（2）重写：发生在子类内部，对父类中方法名相同，参数列表也相同的方法的方法体中的代码进行修改，方法的权限修饰符要大于或等于父类的，如果父类方法的访问权限修饰符为private的话，子类不能进行重写，并且重写的方法抛出的异常类型必须小于等于父类方法抛出的异常，方法返回值类型必须小于或等于父类方法返回值类型。

---

#### 8、equals() 和 == 的区别

1、== 是 Java 中提供的特殊标识符；两个基本数据类型的值使用 == 进行比较时，比较的是两个值是否相等；而两个引用数据类型的对象通过 == 进行比较时，比较的是两个对象的内存地址是否相等。

2、equals() 是 java.lang.Object 类中的成员方法，方法中仍然是通过 == 进行比较的，比较的是两个对象的内存地址；所有的类都隐式地继承了 Object 类，都有 equals()，如果当前类没有重写 equals()，则比较的是两个对象的内存地址，如果重写了 equals()，则比较的规则由 equals() 方法定义的规则决定；基本数据类型不是类，没有继承 Object，没有 equals()，所有，基本数据类型没有办法通过 equals() 进行比较，但是 Java 提供了基本数据类型对应的包装类，而这些包装类又隐式地继承了 Object，并且重写了 equals(),包装类的对象在进行比较的时候，比较的是包装类的值是否相等。

---

#### 9、StringBuffer、StringBuilder、String 的区别

（1）String是不可变的字符串序列、而StringBuffer、StringBuilder是可变的字符序列；String类是由final关键字修饰的,并且Sting用来存储字符的容器char[]也是由final关键字修饰的，内部还没有提供修改的方法；StringBuffer、StringBuilder他两都是继承了AbstractStringBuilder类，用来存储字符的容器char[]没有被final修饰；而且，该类内部提供了许多修改char[]的方法；

（2）String是常量，在编译期间，就已经被赋值了，所以是线程安全的；StringBuffer是在重写AbstractStringBuilder的方法的时候，在方法位置添加了同步锁，也就是synchronized，从而保证了线程安全；StringBuilder是在重写父类方法的时候，直接使用super关键字调用的父类的方法，没有进行线程安全处理，所以是线程不安全的；

（3）String在进行修改的时候，会创建新的对象，很消耗系统资源；StringBuffer是直接修改的对象本身，而不是生成新的对象，将原来的变量指向新创建的对象，但是由于StringBuffer的方法上基本都加上了锁，所以效率较低；StringBuilder也是直接修改的对象本身，并且没有在方法上加锁，所以效率比StringBuffer来说要高

总结：如果操作少的情况下，建议使用String；如果在多线程情况下，建议使用StringBuffer；如果在单线程情况下，并且操作频繁的话，建议使用StringBuilder

---

#### 10、常量池的分类

1、Class 常量池：存在于被 javac 编译之后产生的 .class 二进制字节码文件中，存放着编译期间生成的各种字面量和符号引用，常量池的内容会在类加载后存放到运行时常量池中；



2、运行时常量池：（存在方法区中）JVM 为每个已加载的类或接口都维护一个常量池，池中的数据项像数组项一样，是通过索引访问的；运行时常量池中包含多种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期间解析后才能获得的方法或者字段引用。此时不再是常量池中的符号地址了，而是真实地址，运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。（String.intern（））



3、字符串常量池：（在堆空间中）存放字符串常量

---

#### 11、常见的异常类型

1、java.lang.StackOverFlowError：栈溢出异常



2、java.lang.OutOfMemoryError：内存溢出异常



3、java.util.ConcurrentModificationException：并发修改异常



4、java.lang.InterruptedException：中断异常

---

#### 12、throw和throws的区别

1、throw 用于抛出一个异常对象

2、throws 在方法的参数后用来声明可能会出现的异常，子类在重写父类方法的时候，重写的方法所抛出的异常类型必须小于或等于父类方法抛出的异常类型。



---



#### 13、ArrayList、LinkedList、Vector 的区别



1、ArrayList、Vector 的区别

------



**ArrayList**

1、ArrayList 使用默认的构造器进行创建对象时，会创建一个长度 0 的 Object[]，当第一次向集合中添加单个元素的时候，会将集合容量扩大到10；

2、ArrayList 每次扩容都是扩大为原来的 1.5 倍；

3、ArrayList 是线程不安全的；

------



**Vector**

1、Vector 使用默认的构造器进行创建对象时，会创建一个初始长度为 10 的 Object[]；

2、Vector 每次扩容都是扩大为原来的 2 倍；

3、Vector 是线程安全的，因为 Vector 向外部提供的方法都加了 synchronized；

------



**共同点**：

1、都继承了AbstractList，都实现了 List 接口；

2、底层都是使用 Object[] 来保存元素

------



2、ArrayList、LinkedList 的区别

1、数据结构不同：ArrayList 使用的是对象数组，而 LinkedList 使用的是双向链表

2、容量大小不同：ArrayList 的容量为 Integer 的最大值，而 LinkedList 没有最大值

3、操作数据的效率不同：

- ArrayList 底层使用的是对象数组，里面的元素在内存中都是连续存储的，并且数组中都为同一类型的元素（指定数组元素类型）支持随机访问（实现了 RandomAccess 接口），所以对读操作的效率很高，但是在进行插入和删除操作时，需要将数组的元素进行移动，所以在插入和删除方面效率低；
- LinkedList 底层使用的是双向链表，每个节点都包含了前驱节点、后继节点还有数据，在进行插入和删除的时候，是通过改变相应的前驱节点和后继节点的指向来实现，所以在修改方面效率高；而在进行获取元素的时候，需要从头节点进行遍历，直到找到要获取的元素的位置为止，所以查找元素的效率低。

---

#### 14、HashMap、HashSet、HashTable 的区别

------



**HashMap、HashSet 的区别**

1、HashMap 实现了 Map 接口，用来保存一组具有映射关系的 k-v 键值对；HashSet 实现了 Set 接口，用来保存特定的元素，这些元素不会重复，且无序；

2、HashSet 的底层就是使用的 HashMap，比如在向 HashSet 中添加元素时，是调用的 HashMap的put() 方法，key 为要保存的元素，而 value 为一个对象常量，其作用是用来进行占位用的；

3、所以，HashMap 是通过key 来计算 hashCode，而 HashSet 是通过元素来计算 hashCode 的，而对于两个对象而言，hashCode可能相同，所以又会通过 equals() 方法做最终的判断



------



**HashMap、HashTable 的区别**

1、两者父类不同：HashMap（AbstractMap）、HashTable（Dictionary）；

2、数据结构不同：HashMap（数组+链表/红黑树）、HashTable（动态数组，每个数组元素中又维护了一个单向链表）；

3、数组类型不同：HashMap（Node[]【hash、key、value、next】）、HashTable（Entry[]【hash、key、value、next】）；

4、初始化容量不同：HashMap（16【使用默认构造器时，没有对数组进行初始化，当第一次添加的时候，会扩容到初始化容量】）、HashTable（11）；

5、扩容大小不同：HashMap（为原来的两倍）、HashTable（2n+1）；

6、添加元素的方式不同；

7、线程是否安全：HashMap（线程不安全）、HashTable（线程安全）；

8、空 key、value 的支持：HashMap（HashMap中支持key为null，但只能有一个这样的key；可以有一个或多个键所对应的值为null）、HashTable（HashTable中的key和value都不能为null）；

9、扩容方式不同；

10、计算 hash 值方式不同；

---

#### 15、HashMap 的工作原理是什么？

​	HashMap 底层是采用的数组+链表/红黑树的数据结构来实现的，数组中的每一个元素都是一个链表结构，而链表中的每一个节点又是一个 Node 类型，Node 中又包含了要保存的 key 和 value 以及 hash 和下一个元素 next。

​	put() 方法：首先会先拿到 哈希表：Node[] table，然后判断哈希表是否为 null 或者长度为 0，如果是，则通过 resize() 方法进行数组的初始化操作；否则会根据 key 的哈希值计算出元素在数组中要插入的下标位置，计算公式为（n-1）& hash，n 为数组的长度，然后判断该位置的元素是否为 null，如果为 null，说明该下标位置还没有元素，则直接创建 Node 对象，插入到该位置；否则，再比较要添加的元素的 hash 值与该位置元素的 hash 值是否相等，如果相等，再比较两个元素的 key 是否相等，或者该元素的 key 不为 null，并且两个元素的 key 相等，那么就将该位置的元素的值覆盖；如果目标位置的 key 存在，还与要添加的元素的 key 不同，并且该位置的元素的类型为 红黑树，则插入到红黑树中，否则说明该位置为链表结构，然后遍历该链表，在链表的尾部插入，并且判断链表长度是否达到了链表转为红黑树的长度阈值 8，如果达到了，则通过 treeifBin() 方法将链表转为红黑树，当然在该方法内部还会判断当前数组是否达到了链表转红黑树时，数组的最大长度64，如果达到了转换，如果没达到就不转换，而是通过 resize() 方法对数组进行扩容，如果都没有的话，则会在最后根据添加后 HashMap 中的键值对个数是否达到了扩容阈值（数组容量*加载因子）如果达到了进行扩容 ；如果遍历到某个节点时，发现 key 相同，则直接覆盖然后退出循环，并返回被替换的值

​	get() 方法：首先会判断数组是否不为空，并且数组的长度大于0，并且数组的 (n - 1) & hash 位置的元素不为 null，如果这个条件不满足的话，直接返回 null，否则进行下面的判断：如果目标索引位置的元素就是要找的元素（先比较hash值，如果hash值相同再通过 equals() 比较），则直接返回；如果目标索引位置元素的下一个节点不为空，判断：如果类型是红黑树，则从红黑树中查找；否则就是链表，遍历链表查找目标元素。

​	resize() 方法：先拿到扩容前的数组，获取扩容前的数组的大小和阈值；如果原来数组的大小大于0，判断是否超过了最大值（超过了就不再扩容了），然后扩大容量为当前容量的两倍，但不能超过最大值（2的30次方）；如果当前数组没有数据，使用初始化的值（16）；否则（初始化的值为0，则使用默认的初始化容量：16）（第一次的扩容阈值为：0.75 * 16 = 12）；【后面就是根据新容量创建新的 Node[]，然后进行复制，最终将新的 Node[] 返回】。



总结下来：利用 key 的 hash 值来计算出元素的下标位置，然后再通过 equals() 比较，解决 hash 冲突的问题



---

#### 16、Hash 表链表超长以后转化成红黑树，为什么会使用红黑树？

​	首先，链表的话，由于它在查找元素时，是从头节点开始遍历，直到找到要获取的元素为止，查找元素的时间复杂度为O(n)，查找效率低，为了提高查找效率，就可以考虑二叉树，二叉树是通过二分查找算法来进行查找的，它的时间复杂度为O(logn)，相对于链表来说查找效率要更高；

​	但是由于普通二叉树可能会出现数据倾斜，导致普通二叉树退化为链表，所以就需要使用平衡二叉树，而平衡二叉树它在添加元素时，会考虑每个节点的左子树和右子树的高度差，如果达到了允许的最大树高度差的话，会进行旋转，从而避免二叉树退化为一个链表，但是正是由于它是严格控制左右节点树的高度，所以就导致它在插入和删除的时候也会存在大量的旋转操作；

​	所以就考虑使用红黑树，而红黑树也是一种变体的平衡二叉树，它不再严格控制左右子树的高度，并且红黑树的高度依然是O(logn)，且最坏情况下高度为O(2logn)，而在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质，恢复红黑树的特征需要少量(O(logn))的颜色变更和不超过三次树旋转（对于插入操作是两次），虽然插入和删除很复杂，但是仍可以保持为O(logn)次；所以根据分析可以知道，红黑树能够以O(logn)的时间复杂度进行搜索、插入、删除操作，此外，任何不平衡都会在3次旋转之内解决，这是平衡二叉树所不具备的。

---

#### 17、你认为 HashMap 可不可以不使用链表，而直接使用红黑树，或者二叉搜索树、AVL树？

​	我认为 HashMap 之所以没有选择一开始就使用红黑树可能是因为时间和空间的折中考虑，在 Hash 冲突比较小的时候，即使转化为红黑树之后，在时间复杂度中所产生的效果也并不是特别大，而且在 put 的时候效率可能会降低，毕竟每次 put 都要进行非常复杂的红黑树的这种旋转算法来进行旋转操作，另外在空间上的话，每个节点都需要维护更多的一个指针，这就显得有些得不偿失了，最后就是 HashMap 之所以选择红黑树，而不是二叉搜索树，我认为最主要的原因是二叉搜索树在一些极端的情况下，他会退化为一个链表结构；而红黑树是一种平衡树，它可以防止这种退化，所以可以保持平衡，因为红黑树又不像其他的完全的平衡二叉树那样有严格的平衡条件，所以呢，红黑树插入效率要比完全的平黑二叉树要高，所以的话，HashMap 在选择红黑树既可以避免极端情况下的退化，也可以兼顾查询和插入的这种效率。





---

#### 18、final、finally、finalize

**final：**

修饰类：被修饰的类不能被继承

修饰属性：在初始化后不能被修改

修饰方法：不能被子类重写

**finally：**

它是 try-catch-finally 结构的一部分，它与 catch 都可以单独同 try 进行组合使用，在个结构中，finally 中的代码会最后执行，所以通常情况下，finally 是作为某个步骤中的一个兜底操作，比如进行线程或者数据库连接等系统资源的关闭，但是 finally 中的代码也不一定会执行，就比如说手动调用了 System.exit() 方法，或者程序所在的线程死亡、停电等都会导致 finally 中的代码不会被执行。

**finalize：**

finalize()是在java.lang.Object里定义的。这个方法在gc启动，该对象被回收的时候被调用。





---

#### 19、说一下有哪些 IO 类

InputStream/Reader：所有的输入流的基类，前者是字节输入流，后者是字符输入流。

OutputStream/Writer：所有输出流的基类，前者是字节输出流，后者是字符输出流。

按照流的流向分，可以分为输入流和输出流；

按照操作单元划分，可以划分为字节流和字符流；

按照流的角色划分为节点流和处理流。

Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系，Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。

InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。

OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。





---

#### 20、深拷贝与浅拷贝

深拷贝和浅拷贝就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用。

1.浅拷贝是指，只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址所指向的对象，也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象

2.深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，内部的类执行指向的不是同一个对象



---



#### 21、红黑树的特点

1、红黑树的结点不是红色就是黑色

2、根节点是黑色

3、所有叶子结点都是黑色，叶子结点不包含任何关键字信息

4、每个红色节点的两个子节点都是黑色的/不能有连个连续的红色节点

5、对于每一个节点，从该节点到其每一个叶子节点的所有路径都包含相同数目的黑色节点



------

#### 22、什么是反射

反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于一个对象，都能够调用它的任意一个属性和方法；而这种动态获取类和对象的信息以及动态调用对象的方法的功能就是反射。它是通过运行时类对象Class，将类进行解剖，把类的各个组成部分，比如成员变量、方法、构造器等信息映射成一个个对象。然后通过反射，我们可以获得任意一个类的运行时类Class对象，并通过这个对象可以查看这个类的信息、创建任意一个类的实例，并访问该实例的成员、生成一个类的动态代理类或者动态代理对象，而 Java 的反射机制在实际项目中应用广泛，常见的应用场景比如：使用 JDBC 时，如果要创建数据库的连接，则需要先通过反射机制加载数据库的驱动程序；还有多数框架都支持注解/XML 配置，而从配置中解析出来的类是字符串，需要利用反射机制实例化；还可以实现面向切面编程（AOP），在程序运行时创建目标对象的代理对象，从而对目标对象进行增强。


