### 项目流程总结



---

#### 1、商城首页展示



##### 1、网关（全局过滤器）



1. **判断要访问的路径是不是无须登录就能访问的**
   1. 如果是，直接放行
   2. 如果不是，下一步
2. **判断要访问的路径是不是以 "/api/inner" 开头的（内部各个微服务远程调用的接口）**
   1. **如果是，直接响应 json 数据**
   2. 如果不是，下一步
3. **判断要访问的路径是否需要进行权限验证**
   1. 如果是，获取请求头或者 Cookie 中的 token，对 token 进行验证（根据 token 从 redis 中查）
      1. 判断能不能根据这个 token 查到对应的用户
         1. 如果能查到，说明用户处于登录状态，进行 userId、tempId 透传
            1. **过滤器放行**
         2. 如果查不到
            1. **说明 redis 中没有此用户，重定向到登录页**
4. **请求是普通请求，既不是静态资源，也不是必须登录才能访问的**
   1. 获取请求头或者 Cookie 中的 token
   2. 根据 token 去 redis 查用户信息
   3. 判断查到的用户是否存在
      1. **如果不存在，说明这个 token 是假的，直接重定向，打回登录页**
   4. 透传普通请求中的 userId、tempId
   5. 过滤器放行

---

##### 2、web-all 的 controller



1. 远程调用 service-product，查询出所有菜单，封装成一个树形结构
2. 判断远程调用结果是否正常
   1. 正常，将结果添加到请求域中
3. 请求转发到首页



---

##### 3、product-service 的 api



1. 三级分类树形结构查询，返回



---

#### 2、商品检索

##### 1、网关（全局过滤器）



##### 2、web-all 的 controller

1. 远程调用 service-search，获取VO
2. 给请求域中添加浏览器需要的属性列表
3. 请求转发到列表首页



##### 3、search-service 的 api

1. 根据请求参数VO，动态构建出搜索条件
2. 利用 ES 的 template 的 search(搜索条件，返回值类型、索引名) 查询
3. 将查询到的结果进行转换并返回 



----

#### 3、商品详情页

##### 1、网关（全局过滤器）



##### 2、web-all 的 controller

1. 远程调用 service-item，获取 VO	
2. 判断返回状态是否 OK？
   1. 给请求域中设置前端需要的数据
3. 请求转发到商品详情首页



##### 3、service-item 的 api

1. 根据 skuId 获取商品的详细信息
2. 更新商品的热度分
   1. 根据 skuId 从redis 中自增一次并返回该商品的热度分
   2. 每隔 100 次，更新 ES 中商品的热度分



---

#### 4、将商品加入购物车

##### 1、网关（全局过滤器）



##### 2、web-all 的 controller

1. 远程调用 service-cart，传 skuId、num，把指定的商品的数量添加到购物车
2. 判断返回状态码是否 OK？
   1. OK，给请求域中设置商品的信息和商品数量，请求转发到添加页面
   2. 否则，给请求域中添加返回的响应数据，请求转发到订单异常页面



##### 3、service-cart 的 api

1. 根据用户是否登录，决定用哪个 key 来向 redis 中存（如果用户登录了，用 userId，否则用 tempId）
2. 给购物车中添加商品
   1. 根据 key 获取到购物车
   2. 获取商品品类的数量
   3. 判断购物车中是否存在当前商品
      1. 不存在
         1. 判断添加完这个商品的品类后的品类数量是否超过了购物车品类的最大限制，抛出异常
         2. 根据 skuId 远程调用 service-product 获取商品的信息
         3. 转为购物车中要保存的数据模型
         4. 设置好数量
         5. 给 redis 中保存
      2. 存在
         1. 根据 skuId 获取该商品的实时价格
         2. 根据 key、skuId 从 redis 中获取该商品的原来信息
         3. 更新商品
         4. 同步到 redis
3. 如果是临时用户（用户未登录），则给该购物车设置过期时间
4. 返回商品的详细信息



---

#### 5、购物车列表展示



##### 1、网关（全局过滤器）



##### 2、web-all 的controller

1. 请求转发到购物车首页



##### 3、浏览器异步发起请求



##### 4、service-cart 的 controller

1. 根据用户是否登录决定用哪个 key
2. 尝试合并购物车
   1. 判断是否需要合并（用户登录了、临时 id 存在）
      1. 根据临时 id，构建出临时 id 对应的 key
      2. 根据临时 key，获取对应的购物车商品列表
      3. 判断是否进行合并（商品列表不为 null，并且数量大于 0）
         1. 获取 userId 所对应的 key
         2. 遍历购物车商品列表
         3. 获取 skuId、num，调用添加商品到购物车的方法进行添加
         4. 合并一个后就删除该购物车中的这个商品
3. 获取这个购物车中的所有商品并返回





---

#### 6、用户登录



##### 1、网关（全局过滤器）



##### 2、web-all 的 controller

1. 请求转发到登录页



##### 3、用户点击登录



##### 4、网关（全局过滤器）



##### 5、service-user 的 controller

1. 先创建一个登录成功的 VO
2. 根据用户名和加密后的密码去数据库中查
3. 判断查询到的是否为 null
   1. 不是null
      1. 生成一个唯一令牌 token
      2. 以这个 token 为 key，将查询到的用户信息保存到 redis 中，并设置过期时间
      3. 给 VO 设置 token、用户名
      4. 返回 VO
   2. 返回null

---

#### 7、修改购物车商品数量

##### 1、网关（全局过滤器）



##### 2、service-cart 的 controller

1. 根据用户是否登录，确定缓存 key
2. 根据缓存 key 拿到购物车
3. 根据缓存 key 、skuId 获取到指定的商品
4. 修改商品数量
5. 保存到购物车



---

#### 8、删除购物车中选中的商品



##### 1、网关（全局过滤器）



##### 2、web-all 的 conroller

1. 远程调用 service-cart 的删除选中的商品接口
2. 重定向到购物车首页



##### 3、service-cart 的 api

1. 根据用户是否登录，决定用哪个缓存 key
2. 删除指定 key 的商品
   1. 根据缓存 key，获取对应的购物车
   2. 获取指定购物车中选中的商品
   3. 映射收集为被选中的商品id集合
   4. 如果集合不为 null，并且数量大于 0，就删除这些集合中对应的商品





---

#### 9、购物车结算页



##### 1、网关（全局过滤器）



##### 2、web-all 的 controller

1. 远程调用 service-order ，获取订单确认页需要的数据
2. 如果返回状态OK
   1. 向请求域中添加前端需要的信息：商品信息、总数量、总金额、用户地址列表、交易追踪号
3. 请求转发给订单结算页



##### 3、service-order 的 api

1. 获取订单确认页需要的数据
   1. 创建一个需要返回的 VO
   2. 远程调用 service-cart 获取购物车中选中的商品
   3. 对商品列表进行映射
      1. 将每一个商品映射为商品 VO，
      2. 同时根据 skuId 再通过 service-product 查询该商品的实时价格
      3. 远程调用库存服务，根据 skuId、num，查询库存是否足够（0为无货，1为有货）
   4. 将商品 vo 列表添加到 需要返回的 VO 中
   5. 统计商品的数量
      1. 对商品列表进行映射映射为对应的商品数量
      2. 通过 reduce 计算总和
      3. 通过 get 获取最终的结果
      4. 将结果设置为 VO 中
   6. 统计商品的金额
      1. 对商品列表进行映射映射为对应的商品的总价格
      2. 通过 reduce 计算总和
      3. 通过 get 获取最终的结果
      4. 将结果设置为 VO 中
   7. 获取用户的地址列表
      1. 远程调用 service-user，获取用户的地址列表
      2. 设置给 VO
   8. 生成一个追踪号，可以用来对外进行交易、防止重复提交
      1. 给 redis 中也存一份，并设置过期时间
   9. 设置为VO
   10. 返回 VO



---

#### 10、提交订单



##### 1、前端发送异步 POST 请求



##### 2、网关（全局过滤器）



##### 3、service-order 的 controller

1. 根据请求体中的订单模型和追踪号提交订单
   1. 先验证追踪号
      1. 先看看有没有，如果有就是正确令牌，并删除（通过 lua 脚本）
   2. 如果验证失败抛出异常（页面已经过期，请重新刷新）
   3. 根据订单模型中的详细列表，再对每个商品去库存服务中验证，验证库存是否足够，把库存不足的商品添加到一个集合中
   4. 如果这个集合不为空，或者数量大于0，说明有商品库存不足
      1. 对集合进行 reduce 操作，获取集合中所有的商品的字符串
      2. 根据字符串，抛出异常（库存不够）
   5. 验证价格
      1. 根据订单模型中的详细列表，再对每个商品去 service-product 中查实时价格
      2. 如果价格不一致同上面一样，reduce 获取字符串，抛出异常（价格不一致）
   6. 都没有问题的话，把订单信息保存到数据库
      1. 根据提交的数据模型和追踪号准备订单数据
         1. 收货人
         2. 用户id
         3. 支付方式
         4. 配送地址
         5. 订单备注
         6. 对外交易号
         7. 交易体
         8. 创建时间
         9. 过期时间
         10. 订单的处理状态
         11. 订单状态
         12. 物流编号
         13. 父订单id
         14. 订单的图片
         15. 当前单被优惠活动减掉的金额
         16. 当前单被优惠券减掉的金额
         17. 总价格订单原始总额
         18. 订单总额
         19. 可还款的最后时间
         20. 运费
         21. 操作时间
      2. 保存订单信息
      3. 保存订单明细信息
      4. 返回订单 id

---

