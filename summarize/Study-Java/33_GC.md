---
title: 33_GC
date: 2022-08-15
author: yincy
---

### GC

---



##### 1、GC 的分代收集算法

1、频繁收集新生代

2、较少收集老年代

3、基本不动元空间

---

##### 2、垃圾判别阶段算法

1、引用计数算法

> JVM 不采用该算法，缺点：
>
> 1、每次对对象赋值时均要维护引用计数器
>
> 2、较难处理循环引用

2、根可达性分析算法

> 从 GC Roots进行遍历，如果一个对象和 GC Roots 没有任何引用链时，说明此对象不可用

Java 中可以作为 GC Roots 的对象：

1、虚拟机栈（栈桢中的局部变量表）中引用的对象

2、方法区中的类静态属性应用的对象

3、方法区中常量引用的对象

4、本地方法栈中 JNI （Native 方法）引用的对象

---



##### 3、垃圾清除阶段算法

1、复制算法（新生代）

> **缺点**：
>
> 1、内存空间不能得到充分利用，浪费了 to 区的内存
>
> 2、如果对象的存活率很高的话，我们进行复制的成本就会变得很高；所以如果想采用复制算法的话，必须保证对象的存活率很低才行



2、标记清除算法（老年代）

> **缺点**：
>
> 1、执行效率不稳定；如果要回收的对象很多，那么标记和清除两个操作会导致程序的执行效率降低
>
> 2、内存碎片化问题；标记和清除会产生大量不连续的内存碎片，内存碎片会导致如果程序需要给大对象分配内存的时候无法找到足够的连续空间而不得不提前触发另一次垃圾收集动作。

3、标记压缩算法（老年代）

标记所有存活的对象，然后将所有存活的对象整理到内存的一个连续区域，然后清除该区域以外的内存，当我们需要再次给新对象分配内存的时候，只需要持有一个内存的起始地址即可

> **缺点**：
> 1、效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。

---

**总结**

内存效率：复制算法 > 标记清除算法 >标记整理算法

内存整齐度：复制算法 = 标记整理算法 > 标记清除算法

内存利用率：标记整理算法 = 标记清除算法 > 复制算法



效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对于来说更平滑一些，但效率上依然不尽人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程。



---

##### 4、分代收集算法

1、年轻代（Young Gen）

> 年轻代特点是区域相对于老年代较小，对象存活率很低。复制算法的效率只与当前存活对象大小有关。



2、老年代 （Tenure Gen）

> 老年代的特点是区域较大，对象存活率高。一般是由标记清除或者是标记清除与标记整理的混合实现。

##### 5、面试题

**1、JVM 内存模型以及分区，需要详细到每个区放什么**

---



**2、堆里面的分区：Eden、survival from to、老年代各自的特点**

---



**3、GC 的三种收集方法：标记清除、标记整理、复制算法的原理与特点分别用在什么地方**

---



**4、Minor GC 与 Full GC 分别在什么时候发生**

---



##### 6、垃圾回收器

**1、查看默认的垃圾回收器**

```shell
java -XX:+PrintCommandLineFlags -version
```

**2、垃圾回收器的组合使用**

- 单 CPU 或小内存，单击程序（-XX:+UseSerialGC）
- 多 CPU，需要最大吞吐量，如后台计算型应用（-XX:+UseParallelGC 或者 -XX:+UseParallelOldGC）
- 多 CPU，追求低停顿时间，需快速响应如互联网应用（-XX:+UseConMarkSweepGC -XX:+ParNewGC）

| 参数                                     | 新生代垃圾收集器         | 新生代算法                           | 老年代垃圾收集器                                             | 老年代算法 |
| ---------------------------------------- | ------------------------ | ------------------------------------ | ------------------------------------------------------------ | ---------- |
| -XX:+UseSerialGC                         | SerialGC                 | 复制                                 | SerialOldGC                                                  | 标整       |
| -XX:+UseParNewGC                         | ParNew                   | 复制                                 | SerialOldGC                                                  | 标整       |
| -XX:+UseParallelGC/-XX:+UseParallelOldGC | Parallel[Scavenge]       | 复制                                 | Parallel Old                                                 | 标整       |
| -XX:+UseConcMarkSweepGC                  | ParNew                   | 复制                                 | CMS + SerialOld 的收集器组合（Serial Old 作为 CMS 出错的后背收集器） | 标清+标整  |
| -XX:+UseG1GC                             | G1 整体采用标记-整理算法 | 局部是通过复制算法，不会产生内存碎片 |                                                              |            |

