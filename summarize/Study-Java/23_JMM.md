---
title: 23_JMM
date: 2022-08-11
author: yincy
---

#### JMM--Java 内存模型

**计算机存储体系：**

本地磁盘 --> 主内存 --> CPU 缓存(一、二、三级) --> CPU

CPU 在操作数据的时候，会根据缓存一致性协议，将数据读取到缓存中

---



**能干嘛**：

1、通过 JMM 来实现线程和主内存之间的抽象关系

2、屏蔽各个硬件平台和操作系统的内存访问差异，实现让 Java 程序能在各种平台下都能达到一致性的内存访问效果



---

**三大特性**

1、可见性：当一个线程 修改了某一个共享变量的值，其他线程能否获取到最新的值；（如果没有可见性，会导致线程脏读）

2、原子性：在多线程情况下，操作不能被其他线程干扰，要么都执行成功，要么都执行失败（比如i++：读取变量、加一、赋值【AtomicInteger 的 getAndIncrement() 自增就是原子性的】）

3、有序性：编译器和处理器为了提高程序的性能，通常会对指令进行重排序，此时可能会产生脏读，因为执行顺序可能会被优化，在多线程环境中线程交替执行，多个线程中使用的变量无法保证一致性。

---

**多线程对变量的读写过程**

1、我们定义的所有共享变量都存储在物理内存中

2、每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝）

3、线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写

4、不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行

---

**多线程先行发生原则之 happens-before**

在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系

作用：判断数据是否存在竞争、线程是否安全（主要是用来保证可见性和有序性）

1、如果一个操作 happens-before 于另一个操作，那么第一个操作的执行结果将对第二个操作可见；而且第一个操作的执行顺序排在第二个操作的执行顺序之前。

2、两个操作之前存在 happens-before 关系，并不意味着一定按照 happens-before 原则制定的顺序执行；如果重排序后的执行结果与按照 happens-before关系执行的结果一致，那么这种重排序并不非法。

---

**8条**

1、次序规则：一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作，前一个操作的结果可以被后续的操作获取

2、锁定规则：一个unLock操作先行发生于后面((这里的“后面”是指时间上的先后))对同一个锁的lock操作

3、volatile 变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的“后面”同样是指时间上的先后

4、传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C

5、线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作

6、线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生

7、线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行

8、对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始对象没有完成初始化之前，是不能调用finalized()方法的

