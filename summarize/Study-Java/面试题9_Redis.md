---
title: 面试题9_Redis
date: 2022-08-16
author: yincy
---

### 面试题9_Redis

---



#### 1、Redis常见数据结构以及使用场景有哪些？

1、 **string**

常见命令：set、get、decr、incr、mget等。

基本特点：string数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。

应用场景：常规计数：微博数，粉丝数等。

2、**hash**

常用命令： hget、hset、hgetall等。

基本特点：hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 

应用场景：存储用户信息，商品信息等。

3、**list**

常用命令: lpush、rpush、lpop、rpop、lrange等。

基本特点：类似于Java中的list可以存储多个数据，并且数据可以重复，而且数据是有序的。

应用场景：存储微博的关注列表，粉丝列表等。

4、**set**

常用命令： sadd、spop、smembers、sunion 等 

基本特点：类似于Java中的set集合可以存储多个数据，数据不可以重复，使用set集合不可以保证数据的有序性。

应用场景：可以利用Redis的集合计算功能，实现微博系统中的共同粉丝、公告关注的用户列表计算。

5、**sorted set**

常用命令： zadd、zrange、zrem、zcard 等。

基本特点：和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。

应用场景：在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜等。

---

#### 2、Redis 提供了哪几种持久化方式？

第一种 RDB，【1】它能够在指定的时间间隔内对内存中的数据进行快照存储，而这个存储的过程是由 Redis 创建的子进程来完成的，在整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能，子进程会先将数据写入到某个临时文件中，等持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。【2】如果需要进行大规模数据的恢复，并且对于数据恢复的完整性要求不是很高的话，那么使用 RDB 要比 AOF更加高效，【3】它的保存策略是通过 save n m 来实现的，n 指的是 n 秒内，m 表示至少有 m 个值发生变化，比如 save 300 10，就表示在 300 秒内如果有 10 个值发生了变化，就保存一次。

第二种 AOF，【1】它是以日志形式记录每个更新操作，它会在 Redis 重新启动时读取这个文件，然后执行新建、修改数据的命令来恢复数据；【2】Redis还能对 AOF 文件进行后台重写，所以 AOF文件的体积不会过大；它有三种保存策略，【3】第一种是 appendfsync always，它指的是每次产生一条新的修改数据的命令都执行保存操作，虽然效率低，但是安全；【4】第二种是 appendfsync eversec，它表示每秒执行一次保存操作，但是如果在这秒内有操作没有保持时发生了断点，还是会丢失1 秒钟的数据；【5】而第三种是 appendfsync no，它表示从不保存，而是将数据交给操作系统来处理，这样虽然快，但是不安全，【6】所以 Redis 推荐并且默认的方式就是每秒 fsync 一次，这种 fsync 策略可以兼顾速度和安全性，但是缺点是比 RDB 更占磁盘空间，恢复备份速度更慢，每次读写都同步的话，有一定的性能压力，并且存在个别 bug，会导致数据不能恢复。

【1】如果只希望数据在redis运行的时候存在，那么也可以不使用任何持久化方式；【2】当然也可以同时开启这两种持久化方式，而在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下，AOF 文件保存的数据集要比 RDB文件保存的数据集要更完整。【3】官方推荐是如果对数据不敏感，可以单独用 RDB；但是不建议单独使用 AOF，因为可能出现 Bug；如果只是用来做纯内存缓存的话，可以都不用。

---

在Redis中提供了两种数据持久化的方式：1、RDB	2、AOF

RDB：定期更新，定期将Redis中的数据生成的快照同步到磁盘等介质上，磁盘上保存的就是Redis的内存快照

优点：数据文件的大小相比于aop较小，使用rdb进行数据恢复速度较快

缺点：比较耗时，存在丢失数据的奉献

AOF：将Redis所执行过的所有指令都记录下来，在下次Redis重启时，只需要执行指令就可以了

优点：数据丢失的风险大大降低了

缺点：数据文件的大小相比于rdb较大，使用aop文件进行数据恢复的时候速度较慢

---

#### 3、Redis 为什么这么快？

1、因为 Redis 是基于内存操作的，数据存在内存中，类似于 HashMap，HashMap 的优点就是查找和操作的时间复杂度都是 O(1)；

2、数据结构简单，对数据操作也简单，Redis 中的数据结构是经过专门设计的；

3、采用单线程，避免了不必要的上下文切换和竞争条件；

4、使用多路 I/O 复用模型，是非阻塞 IO；

---



#### 4、Redis 为什么是单线程的？

Redis 官方表示，因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，而 Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了，Redis是利用队列技术将并发访问变为串行访问；采用单线程，可以避免不必要的上下文切换和竞争条件。



---

#### 5、Redis 服务器的内存大小是多大？

可以在 redis.conf 文件中设置 redis 的最大内存参数：maxmemory，如果这个参数不设置或者设置为0，则 redis 的默认内存大小在 32 位系统中是 3G，而在 64 位系统中不受限制；一般推荐设置 Redis 的内存为最大为物理内存的四分之三，如果是临时设置内存大小的话，可以通过 config set maxmemory 内存大小，它会在服务器重启后失效；可以通过 config get maxmemory 获取当前内存大小（字节类型）

---

#### 6、为什么 Redis 的操作是原子性的？它是怎么保证原子性？

对于 Redis 而言，命令的原子性指的是：一个操作的不可再分，操作要么执行，要么不执行；

Redis 的操作之所以是原子性的，是因为 Redis 是单线程的，并且Redis 本身提供的所有 API 都是原子操作；

并且Redis 中的事可以保证批量操作的原子性。

**多个命令在并发中也是原子性的吗？**

不一定；

所以可以将 get 和 set 改成单命令操作：incr；

使用 Redis 的事务，或者使用 Redis+Lua 脚本的方式实现。

---

#### 7、Redis 有事务吗？

Redis 是有事务的，Redis 中的事务是一组命令的集合，这组命令要么都执行，要么都不执行，Redis 的事务需要使用 multi 开启事务，通过 exec 来结束事务；

当输入 multi 后，服务器返回 Ok 表示事务开启成功，然后依次输入需要在本次事务中执行的所有命令，每次输入一个命令服务器并不会马上执行，而是返回 "queued"，这表示命令已经被服务器接收并且暂时保存起来，最后输入 exec，本次事务中的所有命令才会被依次执行。

Redis 的事务除了保证所有命令要么全部执行，要么全部都不执行外，还能保证一个事务中的命令依次执行而不被其他命令插队，同时，Redis 的事务是不支持回滚的。

---



#### 8、使用 Redis 作为缓存，Redis 数据和 MySQL 数据库的一致性如何实现？

1、使用延时双删策略

在写库前后都进行 redis 的 delete 操作，并且设定合理的超时时间，具体步骤是：【1】先删除缓存，【2】然后再写数据库，【3】再休眠 一段时间（根据具体的业务时间来定，这么做的目的是确保读请求结束，写请求可以删除读请求造成的缓存脏数据），【4】最后再一次删除缓存；当然这种策略还要考虑 redis 和数据库主从同步的耗时，最后的写数据的休眠时间：则在读数据业务逻辑的耗时的基础上，加上几百毫秒即可。

2、设置缓存的过期时间

【1】从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案；【2】所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存；【3】结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。

**如何写完数据库后，再次删除缓存成功？**

上述的方案有一个缺点，那就是操作完数据库后，由于种种原因删除缓存失败，这时可能就会出现数据不一致的情况，这里，我们需要提供一个保障重试的方案。

1、方案一具体流程：

【1】首先更新数据库数据，【2】此时缓存因为种种问题删除失败，【3】然后将需要删除的 key 发送到消息队列，【5】最后继续重试删除操作，直到成功。

不过这个方案有一个缺点，它对业务代码有侵入性；于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库中的 binlog，获得需要操作的数据，然后在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。

2、方案二具体流程：

【1】首先更新数据库数据，【2】然后数据库会将操作信息写入 binlog 日志当中，【3】接下来订阅程序提取出所需要的数据以及 key；【4】然后另起一段非业务代码，获得该信息；【5】再尝试删除缓存操作，发现删除失败；【6】再将这些信息发送到消息队列；【7】最后重新从消息队列中获得该数据，进行重试操作。

---

#### 9、缓存击穿、缓存穿透、缓存雪崩的原因和解决方案？（或者说使用缓存的过程中有没有遇到什么问题，怎么解决的）

**缓存穿透**：

概述：指查询一个一定不存在的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，可能导致 DB 挂掉。

解决方案：

1、查询返回的数据为空，仍把这个空结果进行缓存，但过期时间会比较短

2、布隆过滤器：将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对DB的查询

**缓存击穿**：

概述：对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好这时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，

这个时候大并发的请求可能会瞬间把 DB 压垮。

解决方案：

1、使用互斥锁：当缓存失效时，不立即去load db，先使用如 Redis 的 setnx 去设置一个互斥锁，当操作成功返回时再进行 load db的操作并回设缓存，否则重试get缓存的方法

2、永远不过期：不要对这个key设置过期时间

**缓存雪崩**：

概述：设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB 瞬时压力过重雪崩。与缓存击穿的区别：雪崩是很多key，击穿是某一个key缓存。

解决方案：

将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

---

#### 10、哨兵模式是什么样的？

哨兵模式是 Redis 可用性的解决方案；它是由一个或多个 Sentinel 实例构成的 Sentinel 系统；

如果Master异常，则会进行Master-Slave切换，将其中一Slae作为Master，将之前的Master作为Slave

工作原理：

【1】首先每个 Sentinel 以每秒钟一次的频率向它关联着的 Master 以及其他 Sentinel实例发送一个 ping 命令；【2】如果一个实例最后一次有效回复 ping 命令的时间超过下线时间时，那么这个实例就会被 Sentinel 标记为主观下线；【3】如果一个 Master 被标记为主观下线，则正在监听这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 的确进入了主观下线状态；【4】当有足够数量的 Sentinel 在指定时间范围内确认 Master 的确进入了主观下线状态，则 Master会被标记为客观下线；【5】在一般情况下，每个 Sentinel 会以每 10 秒一次的频率向它已知的所有 Master、Sentinel 发送 info 命令；【6】当 Master 被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Sentinel发送 info 命令的频率会从 10 秒一次改为每秒一次；【7】若没有足够数量的 Sentinel 同意 Master 已经下线，Master 的客观下线状态就会被移除；【8】若 Master 重新向 Sentinel 的 ping 命令返回有效回复，Master 的主观下线状态就会被移除。

---

#### 11、Redis 常见性能问题和解决方案？

1、如果数据比较重要，让某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次

2、为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一局域网内

3、尽量避免在压力很大的主库上添加从库

---

#### 12、MySQL 里有大量数据，如何保证 Redis 中的数据都是热点数据？

可以使用 Redis 的 6 种数据淘汰策略，还可以利用 Redis 的过期删除机制；

当 Redis 内存数据集大小上升到一定大小的时候，就会实施数据淘汰策略，而 Redis 有6 种数据淘汰策略，【1】第一种是no-enviction 它表示禁止驱逐数据；【2】第二种是 allkeys-lru ,它是从数据集中淘汰最少用的；【3】第三种是 volatile-lru 它是将从已设置过期时间的数据集中淘汰最少使用的；【4】第四种是 allkeys-random，它是从数据集中随机淘汰；【5】第五种是volatile-random，它是从已设置过期时间的数据集中随机淘汰；【6】第六种是 volatile-ttl 它是从已经设置过期时间的数据集中挑选将要过期的数据淘汰；



而 Redis 的过期删除机制有三种，分别是【1】立即删除，它是在设置 key-value 的过期时间时，创建一个回调事件，当过期时间达到时，由事件处理器自动执行键的删除操作；【2】第二种是惰性删除，也就是指某个键值过期后，该键值并不会立刻被删除，而是等待下次被使用的时候，才能进行删除；【3】第三种就是定时删除，它是每隔一段时间，对 expire 字典进行检查，删除里面的过期 key。

---

#### 13、Redis 集群方案应该怎么做？都有哪些方案？

在Redis中提供的集群方案总共有三种：

1、主从复制

- 保证高可用性
- 实现故障转移需要手动实现
- 无法实现海量数据存储

2、哨兵模式

- 保证高可用性
- 可以实现自动化的故障转移
- 无法实现海量数据存储

3、Redis分片集群

- 保证高可用性
- 可以实现自动化的故障转移
- 可以实现海量数据存储

---



#### 14、说说 Redis 哈希槽的概念？

Redis 集群没有使用一致性 hash，而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置在哪个槽，集群的每个节点负责一部分 hash 槽。

---

#### 15、Redis 有哪些适合的场景？

可以用来缓存会话，还可以根据 Redis 的不同数据结构，完成不同的需求，比如可以使用 string 类型做视频或者文章的关注和点赞；利用 hash 可以做购物车；利用 list 可以实现队列的功能，从而实现消息的订阅、按照时间顺序显示商品的评论列表；利用 set 可以用来做抽奖，还可以通过它的集合关系实现更加复杂的操作；利用 zset 可以用来做排行榜

---

#### 16、Redis 在项目中的应用

【1】在项目中可以用来做缓存，将热点数据进行缓存，减少和数据库交互的次数，提高系统的效率；【2】可以使用 Redis 的分布式锁，解决缓存击穿；【3】还可以作为消息队列，进行消息的发布和订阅

---

#### 17、简单介绍一下Redis优点和缺点？

优点：

1、本质上是一个 Key-Value 类型的内存数据库，很像memcached

2、整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存

3、因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的Key-Value DB

4、Redis最大的魅力是支持保存多种数据结构(string,list,set,hash,sortedset)，此外单个 value 的最大限制是 1GB，

不像memcached只能保存 1MB 的数据

5、Redis也可以对存入的 Key-Value 设置 expire 时间，因此也可以被当作一个功能加强版的memcached 来用

缺点：

1、Redis 的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。

---

#### 18、系统中为什么要使用缓存？

主要从“高性能”和“高并发”这两点来看待这个问题。

高性能：

假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！

高并发：

直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

---

#### 19、常见的缓存同步方案都有哪些？

同步方案：更改代码业务代码，加入同步操作缓存逻辑的代码(数据库操作完毕以后，同步操作缓存)

异步方案：

1、使用消息队列进行缓存同步：更改代码加入异步操作缓存的逻辑代码(数据库操作完毕以后，将要同步的数据发送到MQ中，MQ的消费者从MQ中获取数据，然后更新缓存)

2、使用阿里巴巴旗下的canal组件实现数据同步：不需要更改业务代码，部署一个canal服务。canal服务把自己伪装成mysql的一个从节点，当mysql数据更新以后，canal会读取binlog

数据，然后在通过canal的客户端获取到数据，更新缓存即可。

---

#### 20、Redis有哪些数据删除策略？

数据删除策略：Redis中可以对数据设置数据的有效时间，数据的有效时间到了以后，就需要将数据从内存中删除掉。而删除的时候就需要按照指定的规则进行删除，这种删除规则就被称

之为数据的删除策略。

Redis中数据的删除策略：

① 定时删除

- 概述：在设置某个key 的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行对其进行删除的操作。

- 优点：定时删除对内存是最友好的，能够保存内存的key一旦过期就能立即从内存中删除。

- 缺点：对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分CPU时间，对服务器的响应时间和吞吐量

  造成影响。

② 惰性删除

- 概述：设置该key过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，

  反之返回该key。

- 优点：对CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。

- 缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多

  这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。

③ 定期删除

- 概述：每隔一段时间，我们就对一些key进行检查，删除里面过期的key(从一定数量的数据库中取出一定数量的随机键

  进行检查，并删除其中的过期键)。

- 优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键

  占用的内存。

- 缺点：难以确定删除操作执行的时长和频率。

  如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。如果执行的太少，那又和惰性删除一样

  了，过期键占用的内存不会及时得到释放。

另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，

这是业务不能忍受的错误。

Redis的过期删除策略：惰性删除 + 定期删除两种策略进行配合使用定期删除函数的运行频率，

在Redis2.6版本中，规定每秒运行10次，大概100ms运行一次。在Redis2.8版本后，可以通过修改配置文件redis.conf 的 **hz** 选项来调整这个次数。

---

#### 21、Redis中有哪些数据淘汰策略？

数据的淘汰策略：当Redis中的内存不够用时，此时在向Redis中添加新的key，那么Redis就会按照某一种规则将内存中

的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。

常见的数据淘汰策略：

```shell
noeviction							# 不删除任何数据，内存不足直接报错(默认策略)
volatile-lru						# 挑选最近最久使用的数据淘汰(举例：key1是在3s之前访问的, key2是在9s之前访问的，删除的就是key2)
volatile-lfu						# 挑选最近最少使用数据淘汰  (举例：key1最近5s访问了4次, key2最近5s访问了9次， 删除的就是key1)
volatile-ttl						# 挑选将要过期的数据淘汰
volatile-random						# 任意选择数据淘汰
allkeys-lru							# 挑选最近最少使用的数据淘汰
allkeys-lfu							# 挑选最近使用次数最少的数据淘汰
allkeys-random						# 任意选择数据淘汰，相当于随机
```

注意：

1、不带allkeys字样的淘汰策略是随机从Redis中选择指定的数量的key然后按照对应的淘汰策略进行删除，带allkeys是对所有的key按照对应的淘汰策略进行删除。

2、缓存淘汰策略常见配置项

```shell
maxmemory-policy noeviction			# 配置淘汰策略
maxmemory ?mb						# 最大可使用内存，即占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。
maxmemory-samples count				# 设置redis需要检查key的个数
```

---

#### 22、Redis中数据库默认是多少个db即作用？

Redis默认支持16个数据库，可以通过配置databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用select命令更换

数据库。

Redis支持多个数据库，并且每个数据库是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。

---



#### 23、Redis中的管道有什么用？

一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应，这样就可以将多个命令发送到服务 器，而不用等待回复，最后在一个步骤中读取该答复。

---

#### 24、Redis事务相关的命令有哪几个？

事务相关的命令：

1、MULTI：用来组装一个事务

2、EXEC：执行一个事物

3、DISCARD：取消一个事务

4、WATCH：用来监视一些key，一旦这些key在事务执行之前被改变，则取消事务的执行

5、UNWATCH：取消 WATCH 命令对所有key的监视

---

#### 25、Redis如何做内存优化？

尽可能使用散列表（hash），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。

比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。

---

#### 26、什么是分布式锁？

概述：在分布式系统中，多个线程访问共享数据就会出现数据安全性的问题。而由于jdk中的锁要求多个线程在同一个jvm中，因此在分布式系统中无法使用jdk中的锁保证数据的安全性，那么此时就需要使用分布式锁。

作用：可以保证在分布式系统中多个线程访问共享数据时数据的安全性

举例：

在电商系统中，用户在进行下单操作的时候需要扣减库存。为了提高下单操作的执行效率，此时需要将库存的数据存储到Redis中。订单服务每一次生成订单之前需要查询一下库存数据，如果存在则生成订单同时扣减库存。在高并发场景下会存在多个订单服务操作Redis，此时就会出现线程安全问题。

分布式锁应该具备哪些条件：

1、在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行

2、高可用的获取锁与释放锁

3、高性能的获取锁与释放锁

4、具备可重入特性

5、具备锁失效机制，防止死锁

可重入特性：获取到锁的线程再次调用需要锁的方法的时候，不需要再次获取锁对象。
使用场景：遍历树形菜单的时候的递归调用。

注意：锁具备可重入性的主要目的是为了防止死锁。

---

#### 27、分布式锁的实现方案都有哪些？

分布式锁的实现方案：

1、数据库

2、zookeeper

3、redis

