---
title: 面试题4_JVM
date: 2022-08-16
author: yincy
---

### 面试题4_JVM



#### 1、JVM 内存分哪几个区？每个区的作用是什么？



1、方法区：【1】在 JDK1.8 之前它是通过永久代实现的，而从 JDK1.8 开始，就使用的元空间，在这个区域内很少发生垃圾回收，但是并不代表不发生 GC，在这里进行的 GC 主要是对方法区里的常量池和对类型的卸载；【2】而方法区它主要是用来存储已经被虚拟机加载的类的信息、常量、静态变量和即使编译器编译后的代码等数据；【3】并且方法区中的内容是被线程所共享的；【4】在方法区中有一个运行时常量池，用于存放静态编译产生的字面量和符号引用，该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。

2、虚拟机栈：【1】虚拟机栈也就是我们平常所成的栈内存，它为 java 方法服务，每个方法在执行的时候都会创建一个栈桢，用于存储局部变量表，操作数栈、动态链接和方法出口等信息；【2】虚拟机是线程私有的，它的声明周期与线程相同；【3】局部变量表里存储的是基本数据类型、returnAddress 类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者对象相关联的位置；局部变量所需的内存空间在编译期间确定；【4】而操作数栈的作用主要是用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式；【5】每个栈桢都包含一个指向运行时常量池中该栈桢所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接，动态链接就是将常量池中的符号引用在运行期间转化为直接引用。

3、本地方法栈：和虚拟机栈类似，只不过本地方法栈为 Native 方法服务

4、堆：java 堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作；

5、程序计数器：内存空间小，字节码解释器工作时通过改变这个技术值可以选取下一条需要执行的字节码指令、分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成，该内存区域是唯一一个 java 虚拟机规范没有规定任何 OOM 情况的区域。

---

#### 2、Java 中有哪些垃圾回收算法？

1、垃圾标记阶段算法：【1】有引用计数算法和根可达性分析算法，不过 Java 使用的是根可达性分析算法，因为该算法是通过以 GC Roots 对象作为起点，从这些起点开始向下搜索，搜索的路径被称为引用链，当一个对象到 GC Roots 没有任何引用链相连时（即从 GC Roots 节点到该节点不可达），则证明该对象是不可用的；【2】在 Java 中可以作为 GC Roots 的对象有：虚拟机栈中引用的对象、方法区类静态属性引用的对象、方法区常量池引用的对象、本地方法栈 JNI 引用的对象；【3】而引用计数算法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一，当一个对象的引用计数器为零时，说明此对象没有被引用，也就是 "死对象"，将会被垃圾回收；而  Java 之所以没有使用这种算法是因为它没有办法解决对象间循环依赖问题。

2、垃圾清除阶段算法：【1】有复制算法，这种算法被应用在新生代，它的优点是效率高，缺点是需要的内存容量大，比较耗内存，所以适合使用在占空间比较小、刷新次数多的新生区；【2】还有标记清除算法，它一般是在老年代由标记清除或者是标记清除与标记整理混合实现的，效率比较低，会产生内存碎片，有点是不需要使用额外空间；【3】标记压缩算法，它也是应用在老年代，效率低速度慢，需要移动对象，但不会产生内存碎片；【4】标记清除压缩算法，应用在占空间大刷新次数少老年代。



---

#### 3、什么情况下会产生 StackOverFlowError（栈溢出）和 OutOfMemoryError（内存溢出）？怎么排查？



1、引发 StackOverFlowError 的常见原因：【1】无限递归循环调用、【2】执行了大量方法，导致线程栈空间耗尽、【3】方法内声明了海量的局部变量、【4】native 代码有栈上分配的逻辑，并且要求的内存还不小，比如 java.net.SocketInputStream.read() 会在栈上要求分配一个 64KB 的缓存；

2、引发 OutOfMemoryError 的常见原因：【1】内存中加载的数据量过于庞大，如一次从数据库取出过多数据、【2】集合类中有对对象的引用，使用完后未清空，从而使得 JVM 不能回收、【3】代码中存在死循环或循环产生过多重复的对象实体、【4】启动参数内存值设定的过小；

3、排查的话，可以通过 jstack 以及 jvisualvm 进行内存快照分析



---



#### 4、Java 的类加载过程？

1、在加载阶段：会通过一个类的全限定名获取该类的二进制字节流，然后将二进制字节流中的静态存储结构转化为方法区中的运行时数据结构，再在内存中生成一个该类的运行时类对象 Class，作为该类的数据访问入口；

2、链接阶段：【1】验证：验证的目的是为了确保 Class 文件的字节流中的信息不会危害到虚拟机，它会进行文件格式验证、元数据验证、字节码验证、符号引用验证；【2】准备：为类的静态变量分配内存并将其初始化为默认值，这些内存都讲在方法区中进行分配；准备阶段不会给实例变量分配内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中；【3】解析：主要完成符号引用到直接引用的转换动作，而这个解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。

3、初始化阶段：初始化是类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制，到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。

---

#### 5、什么是类加载器？类加载器有哪些？

实现通过类的全限定名获取该类的二进制字节流的代码块叫做类加载器。

主要有四种类加载器：

1、启动类加载器（Bootstrap ClassLoader）用来加载 Java 核心类库，无法被 Java 程序直接引用；

2、扩展类加载器（Extension ClassLoader）它用来加载 Java 的扩展库，Java 虚拟机的实现会提供一个扩展库目录，该类加载器在此目录里面查找并加载 Java 类；

3、系统类加载器（System ClassLoader）也叫应用类加载器，它可以根据 Java 应用的类路径来加载 Java 类，一般来说，Java 应用的类都是由它来完成加载的，可以通过 ClassLoader.getSystemClassLoader() 来获取；

4、用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现



---

#### 6、JVM 的回收策略以及 Minor GC 和 Major FC

对象优先在 Java 堆中新生代的 Eden 区分配；大对象会直接进入老年代；而长期存活没有被回收的对象会进入老年代；

当 Eden 区没有足够的空间进行分配时，JVM 会执行一次 Minor GC，Minnor GC 通常发生在新生代的 Eden 区，在这个区的对象生存期短，发生 GC 的频率较高，回收速度快；Full FC/Major GC 发生在老年代，一般情况下，触发老年代 GC 的时候不会触发 Minor GC 但是通过配置，可以在 Full GC 之前进行一次 Minnor GC 这样可以加快老年代的回收速度；

【1】当创建一个对象时，会将对象分配在 Eden 区，如果 Eden 区的空间满了的话，此时会发生 Minnor GC ，会把存活下来的对象存到 SurvivorFrom 区，之后再进行 Minnor GC 时，会扫描 Eden 区和 from 区，对这两个区域进行垃圾回收，经过这次回收后还存活的对象则直接复制到 To区（如果有对象的年龄已经达到了老年的标准15，则将对象移动到老年代），同时把这些对象的年龄+1；【2】然后情况 Eden 和 SurvivorFrom 中的对象，最后 SurvivorTo 和SurvivorFrom 进行交换，原来的 SurvivorTo 成为 下一次 GC 时的 SurvivorFrom 区，部分对象会在 From 和 To 区域中复制来复制去，如此交换15 次，最终如果还是存活，就存到老年代。

---

#### 7、新生区为啥需要Survivor区

如果没有Survivor区，Eden区每进行一次MinorGC存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次MinorGC没有消灭但其实也并不会蹦跶多久，或许第2次第3次就需要被清除。这时候移入老年区，很明显不是一个明智的决定。所以Survivor的存在意义就是减少被送到老年代的对象，进而减少FullGC的发生。Survivor的预筛选保证只有经历15次MinorGC还能在新生代中存活的对象，才会被送到老年代

---

#### 8、新生区为啥需要两个Survivor区，为什么8:1:1？

设置两个Survivor区最大的好处就是解决内存碎片化

---

#### 9、元空间与永久代之间最大的区别

元空间并不在虚拟机中而是使用本机物理内存。因此，默认情况下，元空间的大小仅受本地内存限制

---



#### 10、JVM 参数调优命令

1、设置新生区大小：-Xmn

2、设置 Java 堆大小：-Xmx -Xms

3、查看所有 Java 相关进程：jps -l

4、查看 Java 指定进程的栈信息（价差是否发生死锁）：jstack 进程号

5、使用 Java 的控制台：jconsole

6、输出详细的 GC 处理日志：-XX:+PrintGCDetails

7、Dump 文件分析工具：jvisualvm、mat

8、追踪 Dump 文件：

-XX:+HeapDumpOnOutOfMemoryError

-XX:+HeapDumpPath=文件路径

9、配置垃圾回收器：-XX:+垃圾回收器

10、查看默认的垃圾回收器：

-XX:+PrintCommandLineFlags -version